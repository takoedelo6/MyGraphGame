<!DOCTYPE html>

<html lang="ru">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <title>Color Link: Obsidian Graph Style</title>

    <script src="https://cdn.tailwindcss.com"></script>

    <style>

        body { margin: 0; overflow: hidden; background: #050508; font-family: 'Segoe UI', sans-serif; }

        canvas { display: block; cursor: crosshair; }

        #ui { position: absolute; inset: 0; pointer-events: none; color: #e0e0e0; }

        .panel { pointer-events: auto; background: rgba(10, 10, 15, 0.8); backdrop-filter: blur(10px); border: 1px solid #1e3a8a; padding: 15px; border-radius: 8px; }

        .instructions { position: absolute; bottom: 20px; left: 20px; font-size: 12px; opacity: 0.6; }

    </style>

</head>

<body>

  

<div id="ui" class="flex flex-col items-start p-6">

    <div class="panel">

        <h1 class="text-xs font-bold tracking-widest text-blue-400 uppercase">Graph_Engine_v2</h1>

        <p id="level-label" class="text-2xl font-black text-white">Уровень: 1</p>

        <div id="stats" class="text-[10px] mt-2 text-blue-300 font-mono">NODES: 0 | LINKS: 0</div>

    </div>

  

    <div class="instructions panel">

        ЛКМ: Выбрать/Соединить | ПКМ/Зажать: Двигать камеру | Колесо: Зум

    </div>

  

    <div id="win-screen" class="hidden fixed inset-0 flex items-center justify-center bg-black/60 pointer-events-auto">

        <div class="panel text-center max-w-sm border-yellow-500">

            <h2 class="text-3xl font-bold text-yellow-400 mb-2">СЕТЬ СТАБИЛИЗИРОВАНА</h2>

            <p class="mb-6 text-sm">Все узлы графа успешно синхронизированы.</p>

            <button onclick="game.nextLevel()" class="w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-lg font-bold">ЗАГРУЗИТЬ СЛЕДУЮЩИЙ СЛОЙ</button>

        </div>

    </div>

</div>

  

<canvas id="graphCanvas"></canvas>

  

<script type="module">

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";

    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";

    import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

  

    const firebaseConfig = JSON.parse(__firebase_config);

    const app = initializeApp(firebaseConfig);

    const auth = getAuth(app);

    const db = getFirestore(app);

    const appId = typeof __app_id !== 'undefined' ? __app_id : 'obsidian-graph-style';

  

    class Node {

        constructor(id, type, x, y) {

            this.id = id;

            this.type = type;

            this.pos = { x, y };

            this.vel = { x: (Math.random()-0.5)*2, y: (Math.random()-0.5)*2 };

            this.radius = 12; // Меньше размер — больше похоже на граф

            this.connections = [];

            this.color = { yellow: '#f1c40f', red: '#e74c3c', blue: '#3498db', white: '#fff' }[type];

        }

  

        update(nodes, delta) {

            // Физика графа (отталкивание)

            nodes.forEach(other => {

                if (other === this) return;

                const dx = this.pos.x - other.pos.x;

                const dy = this.pos.y - other.pos.y;

                const dist = Math.sqrt(dx*dx + dy*dy) || 1;

                if (dist < 200) {

                    const force = (200 - dist) * 0.01;

                    this.vel.x += (dx / dist) * force;

                    this.vel.y += (dy / dist) * force;

                }

            });

  

            // Трение

            this.vel.x *= 0.95;

            this.vel.y *= 0.95;

  

            this.pos.x += this.vel.x;

            this.pos.y += this.vel.y;

        }

  

        draw(ctx, camera) {

            const screenX = (this.pos.x + camera.x) * camera.zoom + window.innerWidth/2;

            const screenY = (this.pos.y + camera.y) * camera.zoom + window.innerHeight/2;

            const r = this.radius * camera.zoom;

  

            if (screenX < -50 || screenX > window.innerWidth + 50 || screenY < -50 || screenY > window.innerHeight + 50) return;

  

            ctx.beginPath();

            ctx.arc(screenX, screenY, r, 0, Math.PI*2);

            ctx.fillStyle = this.color;

            ctx.shadowBlur = this.connections.length > 0 ? 15 : 0;

            ctx.shadowColor = this.color;

            ctx.fill();

            ctx.shadowBlur = 0;

  

            if (this.connections.length > 0) {

                ctx.strokeStyle = '#fff';

                ctx.lineWidth = 1;

                ctx.stroke();

            }

        }

    }

  

    class GraphGame {

        constructor() {

            this.canvas = document.getElementById('graphCanvas');

            this.ctx = this.canvas.getContext('2d');

            this.nodes = [];

            this.camera = { x: 0, y: 0, zoom: 1 };

            this.selected = null;

            this.isDragging = false;

            this.lastMouse = { x: 0, y: 0 };

            this.level = 1;

  

            this.init();

        }

  

        async init() {

            this.resize();

            window.addEventListener('resize', () => this.resize());

            // Управление камерой

            this.canvas.addEventListener('mousedown', (e) => {

                if (e.button === 2 || e.shiftKey) {

                    this.isDragging = true;

                } else {

                    this.handleInput(e);

                }

            });

            window.addEventListener('mouseup', () => this.isDragging = false);

            window.addEventListener('mousemove', (e) => {

                if (this.isDragging) {

                    this.camera.x += (e.clientX - this.lastMouse.x) / this.camera.zoom;

                    this.camera.y += (e.clientY - this.lastMouse.y) / this.camera.zoom;

                }

                this.lastMouse = { x: e.clientX, y: e.clientY };

            });

            this.canvas.addEventListener('wheel', (e) => {

                const delta = e.deltaY > 0 ? 0.9 : 1.1;

                this.camera.zoom = Math.min(Math.max(this.camera.zoom * delta, 0.1), 3);

            });

            this.canvas.oncontextmenu = () => false;

  

            const res = await signInAnonymously(auth);

            this.user = res.user;

            await this.loadProgress();

            this.loadLevel(this.level);

            this.animate();

        }

  

        resize() {

            this.canvas.width = window.innerWidth;

            this.canvas.height = window.innerHeight;

        }

  

        loadLevel(num) {

            this.nodes = [];

            this.selected = null;

            document.getElementById('win-screen').classList.add('hidden');

            document.getElementById('level-label').innerText = `Уровень: ${num}`;

            const count = 10 + num * 5;

            const types = ['yellow', 'red', 'blue', 'white'];

            for (let i = 0; i < count; i++) {

                const type = types[Math.floor(Math.random() * (num > 2 ? 4 : 3))];

                this.nodes.push(new Node(i, type, (Math.random()-0.5)*1000, (Math.random()-0.5)*1000));

            }

        }

  

        async saveProgress() {

            if (!this.user) return;

            await setDoc(doc(db, 'artifacts', appId, 'users', this.user.uid, 'save', 'state'), { level: this.level });

        }

  

        async loadProgress() {

            const snap = await getDoc(doc(db, 'artifacts', appId, 'users', this.user.uid, 'save', 'state'));

            if (snap.exists()) this.level = snap.data().level;

        }

  

        handleInput(e) {

            const mx = (e.clientX - window.innerWidth/2) / this.camera.zoom - this.camera.x;

            const my = (e.clientY - window.innerHeight/2) / this.camera.zoom - this.camera.y;

  

            const clicked = this.nodes.find(n => {

                const d = Math.hypot(n.pos.x - mx, n.pos.y - my);

                return d < n.radius + 10;

            });

  

            if (clicked) {

                if (!this.selected) {

                    this.selected = clicked;

                } else if (this.selected !== clicked) {

                    this.connect(this.selected, clicked);

                    this.selected = null;

                }

            } else {

                this.selected = null;

            }

        }

  

        connect(a, b) {

            if (a.type === b.type || a.type === 'white' || b.type === 'white') {

                if (!a.connections.includes(b.id)) {

                    a.connections.push(b.id);

                    b.connections.push(a.id);

                    this.checkWin();

                }

            }

        }

  

        checkWin() {

            if (this.nodes.every(n => n.connections.length > 0)) {

                document.getElementById('win-screen').classList.remove('hidden');

            }

        }

  

        nextLevel() {

            this.level++;

            this.saveProgress();

            this.loadLevel(this.level);

        }

  

        animate() {

            this.ctx.fillStyle = '#050508';

            this.ctx.fillRect(0,0,this.canvas.width, this.canvas.height);

  

            document.getElementById('stats').innerText = `NODES: ${this.nodes.length} | LINKS: ${this.nodes.reduce((a,b)=>a+b.connections.length,0)/2}`;

  

            // Отрисовка связей

            this.ctx.lineWidth = 1 * this.camera.zoom;

            this.nodes.forEach(n => {

                n.connections.forEach(cid => {

                    const target = this.nodes.find(t => t.id === cid);

                    if (target && n.id < target.id) {

                        const x1 = (n.pos.x + this.camera.x) * this.camera.zoom + window.innerWidth/2;

                        const y1 = (n.pos.y + this.camera.y) * this.camera.zoom + window.innerHeight/2;

                        const x2 = (target.pos.x + this.camera.x) * this.camera.zoom + window.innerWidth/2;

                        const y2 = (target.pos.y + this.camera.y) * this.camera.zoom + window.innerHeight/2;

                        this.ctx.beginPath();

                        this.ctx.moveTo(x1, y1);

                        this.ctx.lineTo(x2, y2);

                        this.ctx.strokeStyle = n.type === 'white' ? target.color : n.color;

                        this.ctx.globalAlpha = 0.4;

                        this.ctx.stroke();

                        this.ctx.globalAlpha = 1.0;

                    }

                });

            });

  

            if (this.selected) {

                const sx = (this.selected.pos.x + this.camera.x) * this.camera.zoom + window.innerWidth/2;

                const sy = (this.selected.pos.y + this.camera.y) * this.camera.zoom + window.innerHeight/2;

                this.ctx.beginPath();

                this.ctx.arc(sx, sy, (this.selected.radius + 10) * this.camera.zoom, 0, Math.PI*2);

                this.ctx.strokeStyle = '#3b82f6';

                this.ctx.stroke();

            }

  

            this.nodes.forEach(n => {

                n.update(this.nodes, 1/60);

                n.draw(this.ctx, this.camera);

            });

  

            requestAnimationFrame(() => this.animate());

        }

    }

  

    const game = new GraphGame();

    window.game = game;

  

</script>

</body>

</html>